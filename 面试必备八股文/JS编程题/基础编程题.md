# 牛客JS编程题（中等难度）
## 1.输出实现直角三角形(JS1)
（1）解法1，封装成一个函数，利用循环+repeat来解
```javascript
    var triangle = document.querySelector('.triangle');
    function rightAngle(s, n) {
      let str = ''
      for (let i = 1; i <= n; i++) {
        //repeat(n) 重复复制一个字符串n次
        str += s.repeat(i) + `<br>`
      }
      return str
    }
    triangle.innerHTML = rightAngle('*', 3)

```
（2）解法2. 直接写死输出
```javascript
      var triangle = document.querySelector('.triangle');
      // 补全代码
      triangle.innerHTML=`*<br>**<br>***`
```
（3）解法3. 利用双层for循环来解
```javascript
     var triangle = document.querySelector('.triangle');
    // 补全代码
    function rightAngle(s, n) {
      let str = ''
      for (let i = 1; i <= n; i++) {
        let word = ''
        for (let j = 0; j < i; j++) {
          word += s
        }
        str += word + `<br>`
      }
      return str
    }
    triangle.innerHTML = rightAngle('*', 4)
```
## 2.指定数组范围，随机输出一个无重复数组(JS7)
（1）解法1. 用random生成随机数字，利用indexOf判断数组中是否存在
 - indexOf():该方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1；
 - includes():该方法返回 true or false  来判断数组中是否存在，可以检测NaN, 缺点低版本浏览器支持不是很友好
 - some():用于检测是否有满足条件的元素，有，就不继续检测后面的元素，直接返回true,如果都不符合，返回false
  ```javascript
   let arr = [100,20,50,58,6,69,5]
      // some
      let result = arr.some(e => e === 20) //true
      if (result) {
      //do something...
      };
  ```
  - find():它的参数是一个回调函数，所有数组元素依次遍历该回调函数，直到找出第一个返回值为true的元素，然后返回该元素，否则返回undefined。
  ```javascript
   let arr = [100,20,50,58,6,69,5]
      // some
      let result = arr.find((index,value,arr) => {if(value===20)}) //true
      if (result) {
      //do something...
      };
  ```
 ***
```javascript
  function getUniqueNum(num1, num2, len) {
      let arr = []
      while (arr.length !== len) {
        //math.random()要利用floor,ceil进行取整
        // 需要[n， m):  Math.floor(Math.random() * (m - n)) + n;
        // 需要[n， m]:   Math.floor(Math.random() * (m - n + 1)) + n;
        // 解释：Math.random() * (m - n + 1) 的取值为[0, m - n + 1)， 再加n就是[n, m + 1)， 但这样就可能取到(m, m + 1) 的数， 所以向下取整。
        let num = Math.floor(Math.random() * (num2 - num1 + 1) + num1)

        if (arr.indexOf(num) === -1) {
          arr.push(num)
        }
      }
      return arr
    }
```
（2）解法2.利用set唯一值特性去除
> [set教程详解](https://juejin.cn/post/7154195061734375437)
```javascript
   function getUniqueNum(num1, num2, len) {
      let arr = new Set()
      while (arr.size !== len) {
        let num = Math.floor(Math.random() * (num2 - num1 + 1) + num1)
        arr.add(num)
      }
      //注意要将set集合转换为数组
      //可以利用 扩展运算符...，Array.from(),通过遍历set将每个元素加入到数组当中
      return [...arr]
    }
```
## 3.数组扁平化处理(JS20)
（1）解法1.通过判断数组中每个元素是否是数组，递归处理
- instanceof运算符用于检验构造函数的prototype属性是否出现在对象的原型链中的任何位置，返回一个布尔值。``let a = [];
a instanceof Array; //true``
- 实例的构造函数属性constructor指向构造函数，那么通过constructor属性也可以判断是否为一个数组。`` let a = [1,3,4];
a.constructor === Array;//true``
-  Object.prototype.toString().call()可以获取到对象的不同类型，而且也可以检验是否为数组，比如是否是一个函数，是否是数字等等
  ```javascript
  let a = [1,2,3]
Object.prototype.toString.call(a) === '[object Array]';//true
//检验是否是函数
let a = function () {};
Object.prototype.toString.call(a) === '[object Function]';//true
//检验是否是数字
let b = 1;
Object.prototype.toString.call(a) === '[object Number]';//true

  ```
- Array.isArray() 用于确定传递的值是否是一个数组，返回一个布尔值。``
 let a = [1,2,3]
Array.isArray(a);//true ``
---
```javascript
    function flatten(arr) {
      //如果传入的不是数组元素
      if (!Array.isArray(arr)) return
       let newArr = []
      arr.forEach(item => {
        if (!Array.isArray(item)) {
          newArr.push(item)
        } else {
          newArr=newArr.concat(flatten(item))
        }
      })
      return newArr
    }
```
（2）解法2.toString和split结合
```javaScript
    function flatten(arr) {
      let result = [];
      result = arr.toString() // 1,2,3,4,1
      result = result.split(',') // ['1', '2', '3', '4', '1']
      result = result.map(Number) // [1, 2, 3, 4, 1]
      return result  //可以将三者合并成一句，此处仅为展示响应结果
    }
 ```
 （3）解法3.用reduce方法累加实现（跟递归相似），reduce方法可缓存一个变量，迭代时我们可以操作这个变量，然后返回它。
```javaScript
   function flatten(arr) {
      return arr.reduce((pre, next) => {
        if (Array.isArray(next)) {
          return pre.concat(flatten(next))
        } else {
          return pre.concat(next)
        }
      }, [])}
 ```
  （4）解法4. 扩展运算符+some实现
```javaScript
    function flatten(arr) {
      while (arr.some(item =>
          Array.isArray(item)
        )) {
        arr = [].concat(...arr)
      }
      return arr
    }
 ```
  （5）解法5. ES6的flat方法，flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。默认为1层，参数depth也可以传进 Infinity，代表不论多少层都要展开。
```javaScript
    function flatten(arr) {
      return arr.flat(Infinity)
    }
 ```
